import java.awt.*;
import javax.swing.*;
import java.util.*;

import java.awt.event.*;

public class Pacman extends JPanel
{
  private static final int SIZE = 23;
  private static final int board[][] = getBoard();
  private static final int SCALE = 20;
  private static Graphics2D theG;
  private static final int PACMAN_SIZE = 15;
  private static final int GHOST_SIZE = 20;
  private static final int DOT_SIZE = 5;
  private static final int ENERGIZER_SIZE = DOT_SIZE * 2;
  private static int firstRun = 0;
  
  private static final int WALL = 0;
  private static final int FREE = 1;
  private static final int DOT = 2;
  private static final int ENERGIZER = 3;
  private static final int PACMAN = 4;
  private static final int GHOST = 5;
  private static final int OUT = 6;
  
  private static ThePacman pacman;
  private static TheGhost redGhost, pinkGhost, blueGhost, orangeGhost;
  private static final TheGhost[] theGhosts = new TheGhost[4];
  
  private static int pacmanScore = 0;
  private static int pacmanLives = 3;
  private static JLabel pacmanScoreLabel;
  private static JLabel pacmanLivesLabel;
  
  private static final int CALCULATION_NORMAL = Integer.MAX_VALUE/10;
  private static final int CALCULATION_ENERGIZER = Integer.MAX_VALUE/20; //80
  private static final int FRIGHTENED_MODE = 800; //5 seconds
  
  private static long hitEnergizerAt;
  private boolean controlTouch = false;
  
  private static final Queue<TheGhost> ghostPenQ = new LinkedList<TheGhost>();
  
  public Pacman() {
    super();
    setSize(new Dimension(400, 400));
    setMinimumSize(new Dimension(400, 400));
    addKeyListener(new ControlListener());
    setFocusable(true);
    requestFocusInWindow();
    
    pacmanScoreLabel = new JLabel("Score: " + pacmanScore + "     ", JLabel.RIGHT);
    pacmanScoreLabel.setForeground(Color.white);
    add(pacmanScoreLabel);
    
    pacmanLivesLabel = new JLabel("Lives: " + pacmanLives, JLabel.LEFT);
    pacmanLivesLabel.setForeground(Color.WHITE);
    add(pacmanLivesLabel);
    
    initializeVariables();
  }
  
  /** Initalizes pacman and ghosts start locations */
  public static void initializeVariables() {
    Point ghostStart = null;
    
    for(int i = 0; i < board.length; i++) {
      for(int y = 0; y < board[i].length; y++) {
        //Pacman starting location
        if(board[i][y] == PACMAN)
          pacman = new ThePacman(y, i);
        
        //Ghost starting location
        else if(board[i][y] == GHOST)
          ghostStart = new Point(y, i);
      }
    }
    
    int x = (int) ghostStart.getX();
    int y = (int) ghostStart.getY();
    
    //Middle inside
    blueGhost = new TheGhost(Color.CYAN, x, y);
    board[y][x] = GHOST;
    theGhosts[1] = blueGhost;
    
    //Right inside
    orangeGhost = new TheGhost(Color.ORANGE, x + 2, y);
    board[y][x-2] = GHOST;
    theGhosts[2] = orangeGhost;
    
    //Left inside
    pinkGhost = new TheGhost(Color.PINK, x, y - 2);
    board[y][x-2] = GHOST;
    theGhosts[3] = pinkGhost;
    
    //Outside
    redGhost = new TheGhost(Color.RED, x - 2, y);
    board[y-2][x] = GHOST;
    theGhosts[0] = redGhost;
    
    ghostPenQ.add(blueGhost);
    ghostPenQ.add(orangeGhost);
    ghostPenQ.add(pinkGhost);
  }
  
  
  private static int getItemInNextMove(final PacmanItem movingItem, 
                                       final PacmanItem.Direction theDirection) {
    try {
      switch(theDirection) {
        case UP:
          return board[movingItem.getY()-1][movingItem.getX()];
          
        case DOWN:
          return board[movingItem.getY()+1][movingItem.getX()];
          
        case LEFT:
          return board[movingItem.getY()][movingItem.getX()-1];
          
        case RIGHT:
          return board[movingItem.getY()][movingItem.getX()+1];
          
        default:
          return Integer.MAX_VALUE;
      }
    }
    catch(Exception e) {
      return OUT;
    }
  }
  
  public synchronized void moveItem(final PacmanItem theItem, final PacmanItem.Direction theDirection) {
    controlTouch = false;
    
    if(theDirection == null)
      return;
    
    theItem.setFacingDirection(theDirection);
    
    final int itemInNextDirection = getItemInNextMove(pacman, theDirection);
    
    if(itemInNextDirection == OUT)
      return; 
    
    if(itemInNextDirection == GHOST)
    {
      if(isFrightened())
        eatGhost(theDirection);
      else
        hitGhost();
      return;
    }
    
    if(itemInNextDirection == DOT)
      pacmanScore += 10;
    
    if(itemInNextDirection != WALL) {
      board[pacman.getY()][pacman.getX()] = FREE;
      pacman.move(theDirection);
    }
    
    if(itemInNextDirection == ENERGIZER) {
      hitEnergizerAt = System.currentTimeMillis();
      pacmanScore += 100;
    }
    
    board[pacman.getY()][pacman.getX()] = PACMAN;
    
    updateLabels();
    repaint();
  }
  
  private void eatGhost(final PacmanItem.Direction theDirection) {
    System.out.println("Current Pacman location: " + pacman.getY() + "\t" + pacman.getX());
    System.out.println("Red Ghost: " + redGhost.getY() + "\t" + redGhost.getX());
  }
  
  public void paintComponent(Graphics g) {
    if(firstRun == 0) {
      initializeVariables();
      firstRun++;
    }
    
    theG = (Graphics2D) g;
    drawSquares();
    
    moveItem(pacman, pacman.getFacingDirection());
    try { 
      int temp = 0;
      
      if(((System.currentTimeMillis() - hitEnergizerAt)/1000) <= 5) {
        for(int i = 0; i < CALCULATION_ENERGIZER && !controlTouch; i++)
          temp += i;
      }
      else {
        for(int i = 0; i < CALCULATION_NORMAL && !controlTouch; i++)
          temp += i;
      }
      repaint(); 
    } 
    catch(Exception e) { e.printStackTrace(); }
  }
  
  public void hitGhost() {
    board[pacman.getY()][pacman.getX()] = FREE;
    pacman.returnToStartPosition();
    pacmanLives--;
    updateLabels();
    updatePacmanBoard();
    System.out.println("GHOST");
    repaint();
  }
  
  /** Draws the entire board, including ghosts and pacman */
  public static void drawSquares() {
    for(int i = 0; i < board.length; i++) {
      for(int y = 0; y < board[i].length; y++) {
        switch(board[i][y]) {
          case WALL :
            theG.setColor(Color.BLUE);
            theG.fillRect(y * SCALE, i * SCALE, SCALE, SCALE);
            break;
            
          case FREE :
            drawBlackSquare(i, y);
            break;
            
          case DOT :
            drawBlackSquare(i, y);
            theG.setColor(Color.WHITE);
            theG.fillOval(y * SCALE + 5, i * SCALE + 7, DOT_SIZE, DOT_SIZE);
            break;    
            
          case ENERGIZER :
            drawBlackSquare(i, y);
            theG.setColor(Color.WHITE);
            theG.fillOval(y * SCALE + 5, i * SCALE + 7, ENERGIZER_SIZE, ENERGIZER_SIZE);
            break;
            
          case PACMAN :
            drawBlackSquare(i, y);
            theG.setColor(Color.YELLOW);
            theG.fillOval(y * SCALE, i * SCALE, PACMAN_SIZE, PACMAN_SIZE);
            break;
            
          case GHOST :
            break;
            
          default:
            drawBlackSquare(i, y);
            break;
        }
      }
      
      //Middle inside
      theG.setColor(Color.CYAN);
      drawGhost(blueGhost.getY() * SCALE, blueGhost.getX() * SCALE);
      
      //Right inside
      theG.setColor(Color.ORANGE);
      drawGhost(orangeGhost.getY() * SCALE, orangeGhost.getX() * SCALE);
      
      //Left inside
      theG.setColor(Color.PINK);
      drawGhost(pinkGhost.getY() * SCALE, pinkGhost.getX() * SCALE);
      
      //Outside
      theG.setColor(Color.RED);
      drawGhost(redGhost.getY() * SCALE, redGhost.getX() * SCALE);
    }
  }
  
  private boolean isFrightened() {
    return ((System.currentTimeMillis() - hitEnergizerAt)/ 1000) < FRIGHTENED_MODE;
  }
  
  public static void main(String[] ryan) {
    JFrame theFrame = new JFrame("Pacman");
    theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    theFrame.setSize(500, 500);
    
    theFrame.add(new Pacman());
    theFrame.setVisible(true);
  }
  
  private void updatePacmanBoard() {
    board[pacman.getY()][pacman.getX()] = PACMAN;
  }
  
  /**Listens to keyboard events, sets the facing direction 
    * based on that */
  private class ControlListener implements KeyListener 
  {
    public void keyPressed(KeyEvent e) { 
      
      controlTouch = true;
      
      //Direction item will move in
      PacmanItem.Direction movingDirection;
      
      //Current location becomes nothing for Pacman
      board[pacman.getY()][pacman.getX()] = FREE;
      
      switch(e.getKeyCode())
      {
        //LEFT
        case KeyEvent.VK_LEFT:
          movingDirection = PacmanItem.Direction.LEFT;
          break;
          
          //RIGHT
        case KeyEvent.VK_RIGHT:
          movingDirection = PacmanItem.Direction.RIGHT;
          break;
          
          //UP
        case KeyEvent.VK_UP:
          movingDirection = PacmanItem.Direction.UP;
          break;
          
          //DOWN
        case KeyEvent.VK_DOWN:
          movingDirection = PacmanItem.Direction.DOWN;
          break;
          
        default: 
          movingDirection = null;
          break;
      }
      
      moveItem(pacman, movingDirection);
    }
    public void keyReleased(KeyEvent e) { }
    public void keyTyped(KeyEvent e) { }
  }
  
  
  private static void drawGhost(int y, int x) {
    theG.fillRect(x, y, GHOST_SIZE, GHOST_SIZE);
  }
  
  private static void drawBlackSquare(int x, int y) {
    theG.setColor(Color.BLACK);
    theG.fillRect(y * SCALE, x * SCALE, SCALE, SCALE);
  }
  
  public static int[][] getBoard() {      
    return  cs015.fnl.PacmanSupport.SupportMap.getMap();
  }
  public static void printBoard() {
    for(int y = 0; y < board.length; y++)
      for(int i = 0; i < board[y].length; i++)
      System.out.println(board[y][i]);
  }
  
  private static synchronized void updateLabels() {
    pacmanScoreLabel.setText("Score: " + pacmanScore + "     ");
    pacmanLivesLabel.setText("Lives: " + pacmanLives);
  }
}